---
layout: post
title: Grammars
date:   2015-03-24 12:00:00
edited:
categories: posts
---

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js" type="text/javascript"></script>
<script src="http://www.skulpt.org/static/skulpt.min.js" type="text/javascript"></script>
<script src="http://www.skulpt.org/static/skulpt-stdlib.js" type="text/javascript"></script>
<script src="/assets/python/util.js" type="text/javascript"></script>

<script src="/scripts/codemirror-python.js" type="text/javascript"></script>
<link rel="stylesheet" href="/css/codemirror.css">
<link rel="stylesheet" href="/css/monokai.css">
<style type="text/css">
  .CodeMirror {
    border: 1px solid black;
    font-size: 12px;
    height: auto;
  }
</style>

## Introduction
In this post, I'll go over formal languages and grammars, then describe
an application of context free grammars in natural language processing.

## Formal Language
A [formal language](http://en.wikipedia.org/wiki/Formal_language)
is a set of strings of symbols.
For example, let
*&Sigma; = {a, b, c}* be our symbol set;
then any language over this set is *L &sub; &Sigma;\**
(*L* is a subset of all possible strings of &Sigma;, which is zero or more repetitions of
any element in &Sigma;).
*{}*, *{a, bb, ac}*, *{a, aa, aaa, ...}* are all examples
of languages defined on *&Sigma;*.

The written English language can be described as a formal language over a
symbol set of the English alphabet, numbers, and punctuation. Consider that
while all sentences ever written in English constitute a finite set, there are
infinite possible sentences that can still be written.

Languages can be large and complicated, or infinite like English, making explicitly
writing them out infeasible or impossible. Thus we would like to define
some formalism for specifying languages. In the above example, I made use of "*...*" to
express an infinite list of arbitrary length strings of the letter *a*;
this is already a type of specification, though not very formal.

Various formalisms exist for language specification, such as a language
being a set of strings

  - generated by a formal grammar
  - captured by a [regular expression](http://en.wikipedia.org/wiki/Regular_expression#Formal_language_theory)
  - accepted by a [Turing Machine](http://en.wikipedia.org/wiki/Turing_machine)
  - solving a [constraint satisfaction problem](http://en.wikipedia.org/wiki/Constraint_satisfaction_problem)

When comparing formalisms, we should consider

  - expressive power (can formalism *X* describe more languages than formalism *Y*?)
  - computational efficiency (what is the computational complexity of *X*
    to produce strings from language *L* or check if string *s* is in *L*?)
  - spatial efficiency (how expressive is an *n*-bit formalism?)
  - language equivalence (given *X* that describes *L<sub>1</sub>* and *Y* that
    describes *L<sub>2</sub>*, does *L<sub>1</sub> = L<sub>2</sub>*?)

It so happens that these are often difficult to answer and relate to
deeper concepts in [computability theory](http://en.wikipedia.org/wiki/Computability_theory)
and [computational complexity theory](http://en.wikipedia.org/wiki/Computational_complexity_theory).

Context free grammars, a type of formal grammar, are
rather expressive and easy to reason about and parse for practical purposes.
For these reasons, we will further explore these grammars as a means
to specify languages.

## Formal Grammar
A grammar *g* is a set of production (or rewrite) rules for strings of a formal
language <em><b>L</b>(g)</em> (***L*** is a special function that
produces the language for an input grammar).
A grammar can generate strings of <em><b>L</b>(g)</em>,
given a start symbol, or can implement a "recognizer" that determines whether
some string <em>s &isin; <b>L</b>(g)</em>.

We can define a grammar as a 4-tuple *G = {N, &Sigma;, P, S}*. Where

- *N* is a set of non-terminal symbols (symbols that can be expanded via production rules)
- *&Sigma;* is a set of terminal symbols, disjoint from *N* (akin to *&Sigma;*
  that defines the characters of a language)
- *P* is a set of production rules of the form
  *(N &cap; &Sigma;)\* N (N &cap; &Sigma;)\* &rarr; (N &cap; &Sigma;)\**
  (The left hand side must contain at least one non-terminal, but aside
  from this constraint either side can contain any combination of terminals
  and non-terminals)
- *S &isin; N* is the start symbol

### Example Grammar
Let *N = {A, B, C}*, *&Sigma; = {a, b}*,
*P = {A &rarr; aA, A &rarr; B, B &rarr; bB, B &rarr; b, C &rarr; aA}*,
and *S = C*.

Let's see what language we can generate by successively applying the production rules
until there are no more non-terminal symbols or no rules can be applied.
*L = {C} = {aA} = {aaA, aB} = {aaaA, aaB, abB, ab} = ...*

You may find this is the language *{a<sup>n</sup>b<sup>m</sup> \| n, m &ge; 1}*
(*n* occurrences of *a* followed by *m* of *b*).

### Chomsky Hierarchy
In 1959<sup>[1](#bibliography)</sup>, Noam Chomsky
described
a hierarchy for formal grammars. Each lower type is more expressive than the types
above it.

- Type 3: regular grammars. These grammars are accepted by finite state machines,
  and have production rules of the form *A &rarr; a or A &rarr; aB*
  where *A, B &isin; N* and *a &isin; &Sigma;*. Note that the above example
  is of this type. Type 3 grammars are strictly "right-expanding" and
  can capture any regular expression (because they constitute *regular* languages).

- Type 2: context free grammars (CFGs). Rules are of the form *A &rarr; &alpha;*,
  where *&alpha; &isin; (N &cap; &Sigma;)+* (where + indicates one or more), meaning
  a non-terminal can expand in any direction (i.e. *A* can produce *aA* -- right;
  *aAa* -- middle; *Aa* -- left; or any combination of these). The "context-free"
  indicates that all production rules
  can be applied to a single non-terminal, no matter the symbols that surround it.
  This property makes CFGs computationally easier to handle than less constrained grammars.
  Think of a CFG that can generate the language
  *{a<sup>n</sup>b<sup>n</sup> \| n &ge; 1}*.

- Type 1: context-sensitive grammars (CSGs). The production rules are equivalent
  to the definition of *P* for grammars, with the one constraint that the right hand
  side is not empty. Try thinking of a CSG that can generate
  *{a<sup>n</sup>b<sup>n</sup>c<sup>n</sup> \| n &ge; 1}*.

- Type 0: unrestricted. These are formal grammars exactly as specified by the
  definition we initially introduced. They can produce
  [recursively enumerable languages](http://en.wikipedia.org/wiki/Recursively_enumerable_language)
  and thus can generate any string accepted by a Turing Machine.

Recall the formalisms we introduced for language specification. We now
know that formal grammars are much more general than regular expressions, and
that any language produced by an unrestricted grammar can be enumerated by a
Turing Machine. Constraint satisfaction problems we have not discussed much
(see [[2]](#bibliography) for more information), but they are in fact
similar in computational complexity to unrestricted grammars.

There are many interesting and deep connections between grammars, languages,
and computation machines, a taste of which you can see in
[this](https://en.wikipedia.org/wiki/Template:Formal_languages_and_grammars)
table.

## Modeling English
In order to model written English with a formal language we first make
the assumption we are dealing with the standard written form, the kind
Oxford English Dictionary would accept.

As already mentioned, we can model standard English as an infinite language.
It then follows to wonder: might we be able to construct a grammar
that can generate the language? We should consider what
type of formal language English is to determine which type of grammar is
sufficiently expressive.

English is not a regular language<sup>[3](#bibliography)</sup>.
Intuitively, this is because of non-right-branching features such as center embedding;
"The cat ran", "The cat *the dog chased* ran", "The cat the dog *the rat bit* chased ran", etc.
This construction is of the form *{(The N)<sup>n</sup> Vt<sup>n-1</sup> ran \| N is a noun,
Vt is a transitive verb, n &ge; 1}*, which is similar to the context-free (but not regular)
language *{a<sup>n</sup>b<sup>n</sup> \| n &ge; 1}*.

There is much work on determining the complexity of natural languages, whether
certain ones are context-free (i.e. Dutch and
Swiss-German have been proven to be non-context-free due to
[cross-serial dependencies](http://en.wikipedia.org/wiki/Cross-serial_dependencies)),
but we can quickly see that CFGs are expressive enough for regular
English grammar rules.

### Our Approximation of English
Armed with the theoretical knowledge of languages and grammars, we can take a
shot at constructing a CFG for generating English (well, a little version of it).

Below is an interactive Python script that defines such a CFG.

- *N = {S, NP, VP, PN, N, ADJ, DET, V_INTRANS, V_TRANS}* corresponding
to {sentence, noun phrase, verb phrase, proper noun, noun, adjective, determiner,
intransitive verb, transitive verb}.
- *&Sigma; = {Sasha, Nikolai, Olga, dog, goat, tree, slim, green, the, a, every, runs, barks,
  grows, feeds, walks, bites}*
- *P* is given in the code. Note that one rule *A &rarr; a \| b* is short-hand notation for
  two separate rules *A &rarr; a* and *A &rarr; b*.
- *S = S*; however, feel free to change the *START* variable in the code.

Enjoy!
<form>
  <textarea id="input_grammar"> </textarea>
</form>

<script src="/assets/python/codemirror_setup.js" type="text/javascript"></script>
<script src="/assets/python/grammar_setup.js" type="text/javascript"></script>

<div>
<button type="button" onclick="runit('input_grammar', 'output_grammar')">Run</button>
(Ctrl+Enter)
<br />

<pre class="limit-out" id="output_grammar"></pre>
</div>

<br />

### Some Remarks
The above example is a random generative grammar that weighs each right hand side production
rule equally. We have implicitly introduced a
[probabilistic context free grammar](http://en.wikipedia.org/wiki/Stochastic_context-free_grammar).

Linguistics assumes compositionality of
language. The [principle of compositionality](http://plato.stanford.edu/entries/compositionality/)
says that the meaning of any expression is determined
by the structure and meaning of its constituents. Consider this claim: if some language is
not compositional, one cannot construct a CFG to model it.

### Bibliography
<div id="bibliography">
1. Chomsky, Noam (1959). <a href="http://www.diku.dk/hjemmesider/ansatte/henglein/papers/chomsky1959.pdf">"On certain formal properties of grammars"</a>
<br />

2. Russell and Norvig (2010). *Artificial Intelligence: A Modern Approach"
<a href="http://aima.cs.berkeley.edu/2nd-ed/newchap05.pdf">Chapter 5</a>
<br />
3. Chomsky, Noam (1957). <a href="http://www.edi-linguistics.ir/files/Syntactic-Structure,Chomsky.pdf">"Syntactic Structures"</a>
</div>
